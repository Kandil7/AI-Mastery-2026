# Infrastructure as Code with Terraform\n## Multi-Cloud Deployment Automation for RAG Engine\n\n## Overview\n\nThis guide teaches you how to automate RAG Engine deployments using Terraform, the industry-standard Infrastructure as Code (IaC) tool. You'll learn to create, manage, and version control your infrastructure across AWS, GCP, and Azure.\n\n**Estimated Time:** 4-6 hours  \n**Prerequisites:** Basic understanding of cloud services, completion of cloud deployment guides\n\n**Learning Objectives:**\n1. Understand IaC principles and benefits\n2. Write Terraform configurations for all three clouds\n3. Implement state management and collaboration\n4. Create reusable modules\n5. Set up CI/CD for infrastructure\n6. Manage secrets securely\n7. Implement drift detection\n\n---\n\n## Part 1: Why Infrastructure as Code?\n\n### The Problem with Manual Deployment\n\n**Manual Process (Don't do this):**\n```\n1. Click through AWS console to create VPC\n2. Manually configure security groups\n3. Create RDS instance with specific settings\n4. Deploy ECS cluster with specific configuration\n5. Hope you remember all the settings\n6. Repeat for staging... and production...\n7. Document everything (hopefully)\n8. Panic when someone asks \"How did we configure this?\"\n```\n\n**Problems:**\n- No version control\n- No audit trail\n- Difficult to reproduce\n- Error-prone\n- Time-consuming\n- Knowledge silos\n\n### The IaC Solution\n\n**With Terraform:**\n```hcl\n# infrastructure.tf\nresource \"aws_vpc\" \"main\" {\n  cidr_block = \"10.0.0.0/16\"\n  \n  tags = {\n    Name = \"rag-engine-vpc\"\n    Environment = \"production\"\n  }\n}\n\n# Version controlled, documented, reproducible\n```\n\n**Benefits:**\n- ‚úÖ Version control (Git history)\n- ‚úÖ Code review for infrastructure changes\n- ‚úÖ Automated testing\n- ‚úÖ Easy replication (dev ‚Üí staging ‚Üí prod)\n- ‚úÖ Self-documenting\n- ‚úÖ Team collaboration\n- ‚úÖ Disaster recovery (rebuild in minutes)\n\n---\n\n## Part 2: Terraform Basics\n\n### Installation\n\n```bash\n# macOS\nbrew tap hashicorp/tap\nbrew install hashicorp/tap/terraform\n\n# Windows (Chocolatey)\nchoco install terraform\n\n# Windows (winget)\nwinget install HashiCorp.Terraform\n\n# Linux\nwget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg\necho \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list\nsudo apt update && sudo apt install terraform\n\n# Verify\nterraform version\n```\n\n### Project Structure\n\n```\nterraform/\n‚îú‚îÄ‚îÄ environments/\n‚îÇ   ‚îú‚îÄ‚îÄ dev/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ terraform.tfvars\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ backend.tf\n‚îÇ   ‚îú‚îÄ‚îÄ staging/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îÇ   ‚îî‚îÄ‚îÄ production/\n‚îÇ       ‚îî‚îÄ‚îÄ ...\n‚îú‚îÄ‚îÄ modules/\n‚îÇ   ‚îú‚îÄ‚îÄ vpc/\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tf\n‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ variables.tf\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ outputs.tf\n‚îÇ   ‚îú‚îÄ‚îÄ database/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îÇ   ‚îú‚îÄ‚îÄ cache/\n‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...\n‚îÇ   ‚îî‚îÄ‚îÄ storage/\n‚îÇ       ‚îî‚îÄ‚îÄ ...\n‚îî‚îÄ‚îÄ global/\n    ‚îú‚îÄ‚îÄ iam/\n    ‚îî‚îÄ‚îÄ dns/\n```\n\n### Core Concepts\n\n**Providers:**\n```hcl\n# Tell Terraform which clouds to manage\nprovider \"aws\" {\n  region = \"us-west-2\"\n}\n\nprovider \"google\" {\n  project = \"my-project\"\n  region  = \"us-central1\"\n}\n\nprovider \"azurerm\" {\n  features {}\n}\n```\n\n**Resources:**\n```hcl\n# Define infrastructure components\nresource \"aws_instance\" \"example\" {\n  ami           = \"ami-0c55b159cbfafe1f0\"\n  instance_type = \"t2.micro\"\n}\n```\n\n**Variables:**\n```hcl\n# Make configurations reusable\nvariable \"instance_type\" {\n  description = \"EC2 instance type\"\n  type        = string\n  default     = \"t2.micro\"\n}\n```\n\n**Outputs:**\n```hcl\n# Return useful information\noutput \"instance_ip\" {\n  value = aws_instance.example.public_ip\n}\n```\n\n**State:**\n```\n# Terraform tracks resources in state file\nterraform.tfstate\n\n# Never commit state files! Use remote backend:\n- AWS S3 + DynamoDB\n- Terraform Cloud\n- Google Cloud Storage\n- Azure Blob Storage\n```\n\n---\n\n## Part 3: AWS Infrastructure with Terraform\n\n### Setup\n\n```hcl\n# terraform/aws/main.tf\n\nterraform {\n  required_version = \">= 1.0\"\n  \n  required_providers {\n    aws = {\n      source  = \"hashicorp/aws\"\n      version = \"~> 5.0\"\n    }\n  }\n  \n  backend \"s3\" {\n    bucket         = \"rag-engine-terraform-state\"\n    key            = \"production/terraform.tfstate\"\n    region         = \"us-west-2\"\n    encrypt        = true\n    dynamodb_table = \"terraform-locks\"\n  }\n}\n\nprovider \"aws\" {\n  region = var.aws_region\n  \n  default_tags {\n    tags = {\n      Project     = \"rag-engine\"\n      Environment = var.environment\n      ManagedBy   = \"terraform\"\n    }\n  }\n}\n```\n\n### Variables\n\n```hcl\n# terraform/aws/variables.tf\n\nvariable \"aws_region\" {\n  description = \"AWS region\"\n  type        = string\n  default     = \"us-west-2\"\n}\n\nvariable \"environment\" {\n  description = \"Environment name\"\n  type        = string\n  validation {\n    condition     = contains([\"dev\", \"staging\", \"production\"], var.environment)\n    error_message = \"Environment must be dev, staging, or production.\"\n  }\n}\n\nvariable \"app_name\" {\n  description = \"Application name\"\n  type        = string\n  default     = \"rag-engine\"\n}\n\nvariable \"vpc_cidr\" {\n  description = \"VPC CIDR block\"\n  type        = string\n  default     = \"10.0.0.0/16\"\n}\n\nvariable \"availability_zones\" {\n  description = \"List of availability zones\"\n  type        = list(string)\n  default     = [\"us-west-2a\", \"us-west-2b\", \"us-west-2c\"]\n}\n\nvariable \"db_username\" {\n  description = \"Database username\"\n  type        = string\n  sensitive   = true\n}\n\nvariable \"db_password\" {\n  description = \"Database password\"\n  type        = string\n  sensitive   = true\n}\n```\n\n### VPC Module\n\n```hcl\n# terraform/modules/aws-vpc/main.tf\n\nresource \"aws_vpc\" \"main\" {\n  cidr_block           = var.cidr_block\n  enable_dns_hostnames = true\n  enable_dns_support   = true\n  \n  tags = {\n    Name = \"${var.name}-vpc\"\n  }\n}\n\nresource \"aws_internet_gateway\" \"main\" {\n  vpc_id = aws_vpc.main.id\n  \n  tags = {\n    Name = \"${var.name}-igw\"\n  }\n}\n\nresource \"aws_subnet\" \"public\" {\n  count             = length(var.availability_zones)\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = cidrsubnet(var.cidr_block, 8, count.index)\n  availability_zone = var.availability_zones[count.index]\n  \n  map_public_ip_on_launch = true\n  \n  tags = {\n    Name = \"${var.name}-public-${count.index + 1}\"\n    Type = \"public\"\n  }\n}\n\nresource \"aws_subnet\" \"private\" {\n  count             = length(var.availability_zones)\n  vpc_id            = aws_vpc.main.id\n  cidr_block        = cidrsubnet(var.cidr_block, 8, count.index + 100)\n  availability_zone = var.availability_zones[count.index]\n  \n  tags = {\n    Name = \"${var.name}-private-${count.index + 1}\"\n    Type = \"private\"\n  }\n}\n\nresource \"aws_nat_gateway\" \"main\" {\n  count         = length(var.availability_zones)\n  allocation_id = aws_eip.nat[count.index].id\n  subnet_id     = aws_subnet.public[count.index].id\n  \n  tags = {\n    Name = \"${var.name}-nat-${count.index + 1}\"\n  }\n}\n\nresource \"aws_eip\" \"nat\" {\n  count  = length(var.availability_zones)\n  domain = \"vpc\"\n  \n  tags = {\n    Name = \"${var.name}-eip-${count.index + 1}\"\n  }\n}\n\n# Outputs\noutput \"vpc_id\" {\n  value = aws_vpc.main.id\n}\n\noutput \"public_subnet_ids\" {\n  value = aws_subnet.public[*].id\n}\n\noutput \"private_subnet_ids\" {\n  value = aws_subnet.private[*].id\n}\n```\n\n### ECS Fargate Deployment\n\n```hcl\n# terraform/aws/ecs.tf\n\nresource \"aws_ecs_cluster\" \"main\" {\n  name = \"${var.app_name}-${var.environment}\"\n  \n  setting {\n    name  = \"containerInsights\"\n    value = \"enabled\"\n  }\n  \n  tags = {\n    Name = \"${var.app_name}-${var.environment}\"\n  }\n}\n\nresource \"aws_ecs_task_definition\" \"app\" {\n  family                   = \"${var.app_name}-${var.environment}\"\n  network_mode             = \"awsvpc\"\n  requires_compatibilities = [\"FARGATE\"]\n  cpu                      = \"512\"\n  memory                   = \"1024\"\n  execution_role_arn       = aws_iam_role.ecs_execution.arn\n  task_role_arn            = aws_iam_role.ecs_task.arn\n  \n  container_definitions = jsonencode([\n    {\n      name  = \"rag-engine-api\"\n      image = \"${aws_ecr_repository.app.repository_url}:latest\"\n      essential = true\n      portMappings = [\n        {\n          containerPort = 8000\n          protocol      = \"tcp\"\n        }\n      ]\n      environment = [\n        { name = \"ENVIRONMENT\", value = var.environment },\n        { name = \"DB_HOST\", value = aws_db_instance.main.address },\n        { name = \"DB_NAME\", value = \"rag_engine\" },\n        { name = \"DB_USER\", value = var.db_username },\n        { name = \"REDIS_HOST\", value = aws_elasticache_cluster.main.cache_nodes[0].address }\n      ]\n      secrets = [\n        {\n          name      = \"DB_PASSWORD\"\n          valueFrom = aws_secretsmanager_secret.db_password.arn\n        },\n        {\n          name      = \"JWT_SECRET\"\n          valueFrom = aws_secretsmanager_secret.jwt_secret.arn\n        }\n      ]\n      logConfiguration = {\n        logDriver = \"awslogs\"\n        options = {\n          awslogs-group         = aws_cloudwatch_log_group.app.name\n          awslogs-region        = var.aws_region\n          awslogs-stream-prefix = \"ecs\"\n        }\n      }\n    }\n  ])\n  \n  tags = {\n    Name = \"${var.app_name}-${var.environment}\"\n  }\n}\n\nresource \"aws_ecs_service\" \"app\" {\n  name            = \"${var.app_name}-${var.environment}\"\n  cluster         = aws_ecs_cluster.main.id\n  task_definition = aws_ecs_task_definition.app.arn\n  desired_count   = 3\n  launch_type     = \"FARGATE\"\n  \n  network_configuration {\n    subnets          = module.vpc.private_subnet_ids\n    security_groups  = [aws_security_group.ecs_tasks.id]\n    assign_public_ip = false\n  }\n  \n  load_balancer {\n    target_group_arn = aws_lb_target_group.app.arn\n    container_name   = \"rag-engine-api\"\n    container_port   = 8000\n  }\n  \n  deployment_controller {\n    type = \"ECS\"\n  }\n  \n  deployment_circuit_breaker {\n    enable   = true\n    rollback = true\n  }\n  \n  depends_on = [aws_lb_listener.https]\n  \n  tags = {\n    Name = \"${var.app_name}-${var.environment}\"\n  }\n}\n\nresource \"aws_appautoscaling_target\" \"ecs_target\" {\n  max_capacity       = 10\n  min_capacity       = 3\n  resource_id        = \"service/${aws_ecs_cluster.main.name}/${aws_ecs_service.app.name}\"\n  scalable_dimension = \"ecs:service:DesiredCount\"\n  service_namespace  = \"ecs\"\n}\n\nresource \"aws_appautoscaling_policy\" \"ecs_policy_cpu\" {\n  name               = \"cpu-autoscaling\"\n  policy_type        = \"TargetTrackingScaling\"\n  resource_id        = aws_appautoscaling_target.ecs_target.resource_id\n  scalable_dimension = aws_appautoscaling_target.ecs_target.scalable_dimension\n  service_namespace  = aws_appautoscaling_target.ecs_target.service_namespace\n  \n  target_tracking_scaling_policy_configuration {\n    predefined_metric_specification {\n      predefined_metric_type = \"ECSServiceAverageCPUUtilization\"\n    }\n    target_value       = 70.0\n    scale_in_cooldown  = 300\n    scale_out_cooldown = 60\n  }\n}\n```\n\n### RDS Database\n\n```hcl\n# terraform/aws/rds.tf\n\nresource \"aws_db_subnet_group\" \"main\" {\n  name       = \"${var.app_name}-${var.environment}\"\n  subnet_ids = module.vpc.private_subnet_ids\n  \n  tags = {\n    Name = \"${var.app_name}-${var.environment}\"\n  }\n}\n\nresource \"aws_db_instance\" \"main\" {\n  identifier     = \"${var.app_name}-${var.environment}\"\n  engine         = \"postgres\"\n  engine_version = \"14\"\n  instance_class = var.environment == \"production\" ? \"db.t3.medium\" : \"db.t3.micro\"\n  \n  allocated_storage     = 20\n  max_allocated_storage = 100\n  storage_type          = \"gp2\"\n  storage_encrypted     = true\n  \n  db_name  = \"rag_engine\"\n  username = var.db_username\n  password = var.db_password\n  \n  vpc_security_group_ids = [aws_security_group.rds.id]\n  db_subnet_group_name   = aws_db_subnet_group.main.name\n  \n  backup_retention_period = var.environment == \"production\" ? 7 : 1\n  backup_window          = \"03:00-04:00\"\n  maintenance_window     = \"Mon:04:00-Mon:05:00\"\n  \n  skip_final_snapshot = var.environment != \"production\"\n  deletion_protection = var.environment == \"production\"\n  \n  performance_insights_enabled = var.environment == \"production\"\n  \n  tags = {\n    Name = \"${var.app_name}-${var.environment}-postgres\"\n  }\n}\n\nresource \"aws_security_group\" \"rds\" {\n  name_prefix = \"${var.app_name}-rds-\"\n  vpc_id      = module.vpc.vpc_id\n  \n  ingress {\n    from_port       = 5432\n    to_port         = 5432\n    protocol        = \"tcp\"\n    security_groups = [aws_security_group.ecs_tasks.id]\n  }\n  \n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \"-1\"\n    cidr_blocks = [\"0.0.0.0/0\"]\n  }\n  \n  tags = {\n    Name = \"${var.app_name}-${var.environment}-rds-sg\"\n  }\n}\n```\n\n### Apply AWS Infrastructure\n\n```bash\n# Initialize Terraform\ncd terraform/aws\nterraform init\n\n# Plan changes\nterraform plan -var-file=\"terraform.tfvars\"\n\n# Apply changes\nterraform apply -var-file=\"terraform.tfvars\"\n\n# Destroy (when needed)\nterraform destroy -var-file=\"terraform.tfvars\"\n```\n\n---\n\n## Part 4: GCP Infrastructure with Terraform\n\n### Setup\n\n```hcl\n# terraform/gcp/main.tf\n\nterraform {\n  required_version = \">= 1.0\"\n  \n  required_providers {\n    google = {\n      source  = \"hashicorp/google\"\n      version = \"~> 5.0\"\n    }\n  }\n  \n  backend \"gcs\" {\n    bucket = \"rag-engine-terraform-state\"\n    prefix = \"production\"\n  }\n}\n\nprovider \"google\" {\n  project = var.gcp_project_id\n  region  = var.gcp_region\n}\n```\n\n### Cloud Run Deployment\n\n```hcl\n# terraform/gcp/cloudrun.tf\n\nresource \"google_cloud_run_service\" \"api\" {\n  name     = \"${var.app_name}-${var.environment}\"\n  location = var.gcp_region\n  \n  template {\n    spec {\n      container_concurrency = 80\n      timeout_seconds      = 300\n      service_account_name = google_service_account.cloud_run.email\n      \n      containers {\n        image = \"gcr.io/${var.gcp_project_id}/${var.app_name}:latest\"\n        \n        ports {\n          container_port = 8000\n        }\n        \n        resources {\n          limits = {\n            cpu    = \"2\"\n            memory = \"2Gi\"\n          }\n        }\n        \n        env {\n          name  = \"ENVIRONMENT\"\n          value = var.environment\n        }\n        \n        env {\n          name  = \"DB_HOST\"\n          value = google_sql_database_instance.main.connection_name\n        }\n        \n        env {\n          name = \"DB_PASSWORD\"\n          value_from {\n            secret_key_ref {\n              name = google_secret_manager_secret.db_password.secret_id\n              key  = \"latest\"\n            }\n          }\n        }\n      }\n      \n      scaling {\n        min_instances = var.environment == \"production\" ? 2 : 0\n        max_instances = 10\n      }\n    }\n    \n    metadata {\n      annotations = {\n        \"run.googleapis.com/cloudsql-instances\" = google_sql_database_instance.main.connection_name\n        \"run.googleapis.com/vpc-access-connector\" = google_vpc_access_connector.main.id\n        \"autoscaling.knative.dev/maxScale\" = \"10\"\n      }\n    }\n  }\n  \n  traffic {\n    percent         = 100\n    latest_revision = true\n  }\n  \n  depends_on = [google_secret_manager_secret_version.db_password]\n}\n\nresource \"google_cloud_run_service_iam_member\" \"public_access\" {\n  service  = google_cloud_run_service.api.name\n  location = google_cloud_run_service.api.location\n  role     = \"roles/run.invoker\"\n  member   = \"allUsers\"\n}\n\n# Cloud Run domain mapping\nresource \"google_cloud_run_domain_mapping\" \"api\" {\n  location = var.gcp_region\n  name     = \"api.${var.domain}\"\n  \n  metadata {\n    namespace = var.gcp_project_id\n  }\n  \n  spec {\n    route_name       = google_cloud_run_service.api.name\n    force_override   = true\n  }\n}\n```\n\n### Cloud SQL\n\n```hcl\n# terraform/gcp/database.tf\n\nresource \"google_sql_database_instance\" \"main\" {\n  name             = \"${var.app_name}-${var.environment}\"\n  database_version = \"POSTGRES_14\"\n  region           = var.gcp_region\n  \n  settings {\n    tier = var.environment == \"production\" ? \"db-f1-micro\" : \"db-f1-micro\"\n    \n    ip_configuration {\n      ipv4_enabled = false\n      private_network = google_compute_network.main.id\n    }\n    \n    backup_configuration {\n      enabled    = true\n      start_time = \"03:00\"\n    }\n    \n    insights_config {\n      query_insights_enabled = true\n    }\n  }\n  \n  deletion_protection = var.environment == \"production\"\n}\n\nresource \"google_sql_database\" \"app\" {\n  name     = \"rag_engine\"\n  instance = google_sql_database_instance.main.name\n}\n\nresource \"google_sql_user\" \"app\" {\n  name     = \"rag_user\"\n  instance = google_sql_database_instance.main.name\n  password = var.db_password\n}\n```\n\n---\n\n## Part 5: Azure Infrastructure with Terraform\n\n### Setup\n\n```hcl\n# terraform/azure/main.tf\n\nterraform {\n  required_version = \">= 1.0\"\n  \n  required_providers {\n    azurerm = {\n      source  = \"hashicorp/azurerm\"\n      version = \"~> 3.0\"\n    }\n  }\n  \n  backend \"azurerm\" {\n    resource_group_name  = \"terraform-state-rg\"\n    storage_account_name = \"ragterraformstate\"\n    container_name       = \"tfstate\"\n    key                  = \"production.terraform.tfstate\"\n  }\n}\n\nprovider \"azurerm\" {\n  features {\n    resource_group {\n      prevent_deletion_if_contains_resources = false\n    }\n  }\n}\n```\n\n### Container Apps\n\n```hcl\n# terraform/azure/containerapps.tf\n\nresource \"azurerm_container_app_environment\" \"main\" {\n  name                       = \"${var.app_name}-${var.environment}\"\n  resource_group_name        = azurerm_resource_group.main.name\n  location                   = var.azure_location\n  log_analytics_workspace_id = azurerm_log_analytics_workspace.main.id\n}\n\nresource \"azurerm_container_app\" \"api\" {\n  name                         = \"${var.app_name}-api\"\n  container_app_environment_id = azurerm_container_app_environment.main.id\n  resource_group_name          = azurerm_resource_group.main.name\n  revision_mode                = \"Single\"\n  \n  identity {\n    type = \"SystemAssigned\"\n  }\n  \n  template {\n    container {\n      name   = \"rag-engine-api\"\n      image  = \"${azurerm_container_registry.main.login_server}/${var.app_name}:latest\"\n      cpu    = 1.0\n      memory = \"2Gi\"\n      \n      env {\n        name  = \"ENVIRONMENT\"\n        value = var.environment\n      }\n      \n      env {\n        name  = \"DB_HOST\"\n        value = azurerm_postgresql_flexible_server.main.fqdn\n      }\n      \n      env {\n        name        = \"DB_PASSWORD\"\n        secret_name = \"db-password\"\n      }\n    }\n    \n    min_replicas = var.environment == \"production\" ? 2 : 0\n    max_replicas = 10\n  }\n  \n  secret {\n    name  = \"db-password\"\n    value = var.db_password\n  }\n  \n  ingress {\n    external_enabled = true\n    target_port      = 8000\n    \n    traffic_weight {\n      latest_revision = true\n      percentage      = 100\n    }\n  }\n}\n```\n\n---\n\n## Part 6: Multi-Cloud Abstraction\n\n### Using Terraform Workspaces\n\n```bash\n# Create workspaces for different environments\nterraform workspace new dev\nterraform workspace new staging\nterraform workspace new production\n\n# Select workspace\nterraform workspace select production\n\n# Each workspace has its own state\nterraform workspace list\n```\n\n### Conditional Resources by Cloud\n\n```hcl\n# terraform/modules/multi-cloud/main.tf\n\nlocals {\n  is_aws   = var.cloud_provider == \"aws\"\n  is_gcp   = var.cloud_provider == \"gcp\"\n  is_azure = var.cloud_provider == \"azure\"\n}\n\n# AWS Resources\nmodule \"aws_infrastructure\" {\n  count  = local.is_aws ? 1 : 0\n  source = \"../aws\"\n  \n  environment = var.environment\n  app_name    = var.app_name\n}\n\n# GCP Resources\nmodule \"gcp_infrastructure\" {\n  count  = local.is_gcp ? 1 : 0\n  source = \"../gcp\"\n  \n  environment = var.environment\n  app_name    = var.app_name\n}\n\n# Azure Resources\nmodule \"azure_infrastructure\" {\n  count  = local.is_azure ? 1 : 0\n  source = \"../azure\"\n  \n  environment = var.environment\n  app_name    = var.app_name\n}\n```\n\n---\n\n## Part 7: State Management\n\n### Why Remote State?\n\n**Local State Problems:**\n- Lost if laptop dies\n- No team collaboration\n- No locking (concurrent changes)\n- Not encrypted\n\n**Remote State Solutions:**\n\n**AWS S3 + DynamoDB:**\n```hcl\nterraform {\n  backend \"s3\" {\n    bucket         = \"rag-engine-terraform-state\"\n    key            = \"production/terraform.tfstate\"\n    region         = \"us-west-2\"\n    encrypt        = true\n    kms_key_id     = \"arn:aws:kms:us-west-2:123456789:key/12345678-1234-1234-1234-123456789012\"\n    dynamodb_table = \"terraform-locks\"\n  }\n}\n```\n\n**Terraform Cloud:**\n```hcl\nterraform {\n  cloud {\n    organization = \"rag-engine\"\n    \n    workspaces {\n      name = \"production\"\n    }\n  }\n}\n```\n\n### State Security Best Practices\n\n```bash\n# 1. Encrypt state at rest (all backends support this)\n# 2. Use least-privilege access to state storage\n# 3. Enable versioning on state buckets\n# 4. Use state locking (prevents concurrent modifications)\n# 5. Never commit state files to git\n\n# Add to .gitignore\necho \"*.tfstate\" >> .gitignore\necho \"*.tfstate.*\" >> .gitignore\necho \".terraform/\" >> .gitignore\necho \"*.tfvars\" >> .gitignore  # If contains secrets\n```\n\n---\n\n## Part 8: Secrets Management\n\n### Never Hardcode Secrets!\n\n**Bad:**\n```hcl\n# DON'T DO THIS\nresource \"aws_db_instance\" \"main\" {\n  password = \"supersecret123\"  # ‚ùå NEVER!\n}\n```\n\n**Good - Environment Variables:**\n```bash\n# Set via environment\nexport TF_VAR_db_password=$(openssl rand -base64 32)\nterraform apply\n```\n\n**Good - Secret Managers:**\n```hcl\n# AWS Secrets Manager\ndata \"aws_secretsmanager_secret_version\" \"db_password\" {\n  secret_id = \"rag-engine/production/db-password\"\n}\n\nresource \"aws_db_instance\" \"main\" {\n  password = data.aws_secretsmanager_secret_version.db_password.secret_string\n}\n\n# GCP Secret Manager\ndata \"google_secret_manager_secret_version\" \"db_password\" {\n  secret = \"db-password\"\n}\n\n# Azure Key Vault\ndata \"azurerm_key_vault_secret\" \"db_password\" {\n  name         = \"db-password\"\n  key_vault_id = azurerm_key_vault.main.id\n}\n```\n\n**Good - Terraform Cloud Variables:**\n```bash\n# Set sensitive variables in Terraform Cloud UI\nterraform cloud\n```\n\n---\n\n## Part 9: CI/CD for Infrastructure\n\n### GitHub Actions Workflow\n\n```yaml\n# .github/workflows/terraform.yml\nname: 'Terraform'\n\non:\n  push:\n    branches: [ main ]\n    paths: [ 'terraform/**' ]\n  pull_request:\n    branches: [ main ]\n    paths: [ 'terraform/**' ]\n\njobs:\n  terraform:\n    name: 'Terraform'\n    runs-on: ubuntu-latest\n    environment: production\n    \n    defaults:\n      run:\n        shell: bash\n        working-directory: terraform/aws\n    \n    steps:\n    - name: Checkout\n      uses: actions/checkout@v3\n    \n    - name: Setup Terraform\n      uses: hashicorp/setup-terraform@v2\n      with:\n        terraform_version: \"1.5.0\"\n        terraform_wrapper: false\n    \n    - name: Configure AWS Credentials\n      uses: aws-actions/configure-aws-credentials@v2\n      with:\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: us-west-2\n    \n    - name: Terraform Format\n      id: fmt\n      run: terraform fmt -check\n      continue-on-error: true\n    \n    - name: Terraform Init\n      id: init\n      run: terraform init\n    \n    - name: Terraform Validate\n      id: validate\n      run: terraform validate -no-color\n    \n    - name: Terraform Plan\n      id: plan\n      if: github.event_name == 'pull_request'\n      run: terraform plan -no-color -input=false\n      continue-on-error: true\n    \n    - name: Update Pull Request\n      uses: actions/github-script@v6\n      if: github.event_name == 'pull_request'\n      env:\n        PLAN: \"terraform\\n${{ steps.plan.outputs.stdout }}\"\n      with:\n        github-token: ${{ secrets.GITHUB_TOKEN }}\n        script: |\n          const output = `#### Terraform Format and Style üñå\`\${{ steps.fmt.outcome }}\`\n          #### Terraform Initialization ‚öôÔ∏è\`\${{ steps.init.outcome }}\`\n          #### Terraform Validation ü§ñ\`\${{ steps.validate.outcome }}\`\n          #### Terraform Plan üìñ\`\${{ steps.plan.outcome }}\`\n          \n          <details><summary>Show Plan</summary>\n          \n          \`\`\`terraform\n          \${process.env.PLAN}\n          \`\`\`\n          \n          </details>\n          \n          *Pushed by: @\${{ github.actor }}, Action: \`\${{ github.event_name }}\`*`;\n          \n          github.rest.issues.createComment({\n            issue_number: context.issue.number,\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            body: output\n          })\n    \n    - name: Terraform Plan Status\n      if: steps.plan.outcome == 'failure'\n      run: exit 1\n    \n    - name: Terraform Apply\n      if: github.ref == 'refs/heads/main' && github.event_name == 'push'\n      run: terraform apply -auto-approve -input=false\n```\n\n### Atlantis (Terraform PR Automation)\n\n```yaml\n# atlantis.yaml\nversion: 3\nprojects:\n- dir: terraform/aws\n  workflow: aws\n  autoplan:\n    when_modified: [\"*.tf\", \"../modules/**/*.tf\"]\n    enabled: true\n\nworkflows:\n  aws:\n    plan:\n      steps:\n      - init\n      - plan:\n          extra_args: [\"-lock=false\"]\n    apply:\n      steps:\n      - apply\n```\n\n---\n\n## Part 10: Testing and Validation\n\n### Terraform Validate\n\n```bash\n# Check syntax and basic validation\nterraform validate\n\n# Format check\nterraform fmt -check\n\n# Format and write\nterraform fmt -recursive\n```\n\n### Policy as Code with Sentinel/OPA\n\n```hcl\n# policies/restrict-instance-type.sentinel\nimport \"tfplan\"\n\nallowed_instance_types = [\n  \"t3.micro\",\n  \"t3.small\",\n  \"t3.medium\",\n]\n\naws_instances = filter tfplan.resource_changes as _, rc {\n  rc.type is \"aws_instance\" and\n  rc.mode is \"managed\" and\n  (rc.change.actions contains \"create\" or rc.change.actions contains \"update\")\n}\n\nviolations = 0\nfor aws_instances as _, instance {\n  if instance.change.after.instance_type not in allowed_instance_types {\n    violations += 1\n    print(\"Instance type not allowed:\", instance.change.after.instance_type)\n  }\n}\n\nmain = rule {\n  violations is 0\n}\n```\n\n### Terratest (Go-based Testing)\n\n```go\n// test/terraform_test.go\npackage test\n\nimport (\n  \"testing\"\n  \"github.com/gruntwork-io/terratest/modules/terraform\"\n  \"github.com/stretchr/testify/assert\"\n)\n\nfunc TestTerraformAwsVpc(t *testing.T) {\n  t.Parallel()\n  \n  terraformOptions := terraform.WithDefaultRetryableErrors(t, &terraform.Options{\n    TerraformDir: \"../terraform/aws\",\n    Vars: map[string]interface{}{\n      \"environment\": \"test\",\n      \"db_password\": \"testpassword123\",\n    },\n  })\n  \n  defer terraform.Destroy(t, terraformOptions)\n  \n  terraform.InitAndApply(t, terraformOptions)\n  \n  vpcID := terraform.Output(t, terraformOptions, \"vpc_id\")\n  assert.NotEmpty(t, vpcID)\n  \n  publicSubnets := terraform.OutputList(t, terraformOptions, \"public_subnet_ids\")\n  assert.Equal(t, 3, len(publicSubnets))\n}\n```\n\n---\n\n## Part 11: Drift Detection\n\n### What is Drift?\n\nDrift occurs when infrastructure is modified outside of Terraform (e.g., via console).\n\n### Detecting Drift\n\n```bash\n# Check for drift\nterraform plan -detailed-exitcode\n\n# Exit codes:\n# 0 - No changes\n# 1 - Error\n# 2 - Changes present (drift detected)\n\n# Automated drift detection script\n#!/bin/bash\nterraform plan -detailed-exitcode -out=plan.tfplan\nEXIT_CODE=$?\n\nif [ $EXIT_CODE -eq 2 ]; then\n  echo \"‚ö†Ô∏è  Drift detected! Infrastructure has changed outside of Terraform.\"\n  terraform show plan.tfplan\n  # Send alert to Slack/Email\n  exit 1\nelif [ $EXIT_CODE -eq 1 ]; then\n  echo \"‚ùå Error running terraform plan\"\n  exit 1\nelse\n  echo \"‚úÖ No drift detected\"\nfi\n```\n\n### Scheduled Drift Detection\n\n```yaml\n# .github/workflows/drift-detection.yml\nname: 'Drift Detection'\n\non:\n  schedule:\n    - cron: '0 */6 * * *'  # Every 6 hours\n\njobs:\n  detect-drift:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v3\n    - uses: hashicorp/setup-terraform@v2\n    - uses: aws-actions/configure-aws-credentials@v2\n      with:\n        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n        aws-region: us-west-2\n    \n    - name: Detect Drift\n      working-directory: terraform/aws\n      run: |\n        terraform init\n        terraform plan -detailed-exitcode || EXIT_CODE=$?\n        if [ \"$EXIT_CODE\" -eq 2 ]; then\n          echo \"::error::Drift detected!\"\n          curl -X POST -H 'Content-type: application/json' \\\n            --data '{\"text\":\"‚ö†Ô∏è Infrastructure drift detected in production!\"}' \\\n            ${{ secrets.SLACK_WEBHOOK_URL }}\n          exit 1\n        fi\n```\n\n---\n\n## Part 12: Production Best Practices\n\n### Module Design\n\n**Principles:**\n1. **Single Responsibility** - One module per resource type\n2. **Reusability** - Use variables, not hardcoded values\n3. **Composition** - Build complex infrastructure from simple modules\n4. **Documentation** - Every module has README.md\n\n```hcl\n# Good module structure\nmodule \"vpc\" {\n  source = \"./modules/vpc\"\n  \n  # Required parameters\n  name = \"rag-engine\"\n  cidr = \"10.0.0.0/16\"\n  \n  # Optional with defaults\n  enable_nat_gateway = var.environment == \"production\"\n  single_nat_gateway = var.environment != \"production\"\n}\n```\n\n### Naming Conventions\n\n```hcl\n# Resource naming\n# Format: {app_name}-{environment}-{resource_type}\n\nresource \"aws_instance\" \"rag_engine_production_api\" {  # ‚ùå Bad\n  # ...\n}\n\nresource \"aws_instance\" \"api\" {  # ‚úÖ Good - use tags instead\n  tags = {\n    Name = \"rag-engine-production-api\"\n    Environment = \"production\"\n  }\n}\n```\n\n### Tagging Strategy\n\n```hcl\nlocals {\n  common_tags = {\n    Project     = \"rag-engine\"\n    Environment = var.environment\n    ManagedBy   = \"terraform\"\n    Owner       = \"platform-team\"\n    CostCenter  = \"engineering\"\n  }\n}\n\n# Apply to all resources\nprovider \"aws\" {\n  default_tags {\n    tags = local.common_tags\n  }\n}\n```\n\n### Documentation\n\n```bash\n# Auto-generate documentation\nterraform-docs markdown . > README.md\n\n# Or use pre-commit hook\ncat > .pre-commit-config.yaml <<EOF\nrepos:\n  - repo: https://github.com/antonbabenko/pre-commit-terraform\n    rev: v1.77.0\n    hooks:\n      - id: terraform_fmt\n      - id: terraform_validate\n      - id: terraform_docs\nEOF\n\n# Install pre-commit\nbrew install pre-commit\npre-commit install\n```\n\n---\n\n## Part 13: Troubleshooting\n\n### Common Issues\n\n**State Lock Errors:**\n```bash\n# Error: Error locking state: Error acquiring the state lock\n# Someone else is running terraform\n\n# Force unlock (USE WITH CAUTION)\nterraform force-unlock <LOCK_ID>\n```\n\n**Resource Already Exists:**\n```bash\n# Import existing resource into state\nterraform import aws_instance.example i-1234567890abcdef0\n\n# Then manage with Terraform\n```\n\n**Dependency Errors:**\n```bash\n# Add explicit dependencies\nresource \"aws_instance\" \"example\" {\n  depends_on = [aws_security_group.example]\n  # ...\n}\n```\n\n### Debugging\n\n```bash\n# Enable debug logging\nexport TF_LOG=DEBUG\nterraform apply\n\n# Log levels: TRACE, DEBUG, INFO, WARN, ERROR\nexport TF_LOG_PATH=./terraform.log\n```\n\n---\n\n## Summary Checklist\n\n### Before Production\n\n- [ ] Remote state backend configured\n- [ ] State locking enabled\n- [ ] Secrets in external vault (not in code)\n- [ ] CI/CD pipeline for automated deployments\n- [ ] Drift detection scheduled\n- [ ] Modules documented with terraform-docs\n- [ ] Pre-commit hooks installed\n- [ ] Team trained on Terraform workflow\n- [ ] Rollback procedure documented\n- [ ] Cost estimates reviewed\n\n### Daily Operations\n\n- [ ] Review Terraform Cloud runs\n- [ ] Monitor drift detection alerts\n- [ ] Update documentation after changes\n- [ ] Rotate credentials regularly\n- [ ] Review and apply security patches\n- [ ] Backup state regularly\n\n---\n\n## Resources\n\n- [Terraform Documentation](https://developer.hashicorp.com/terraform/docs)\n- [Terraform Registry](https://registry.terraform.io/)\n- [Terraform Best Practices](https://www.terraform-best-practices.com/)\n- [Terratest Documentation](https://terratest.gruntwork.io/)\n- [Terraform Cloud](https://cloud.hashicorp.com/products/terraform)\n\n---\n\n## Next Steps\n\n1. Set up Terraform Cloud or S3 backend\n2. Create your first module\n3. Implement CI/CD pipeline\n4. Add automated testing\n5. Set up drift detection\n6. Train your team\n\n**You now have Infrastructure as Code mastery for all three clouds!** üöÄ\n
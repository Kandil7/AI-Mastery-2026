# RAG Engine Mini - Domain Layer Deep Dive

## Introduction

The domain layer represents the heart of the RAG Engine Mini application. It contains the pure business logic and entities that define the core concepts of the system, completely free from external dependencies. This layer embodies the business rules and domain knowledge of a RAG system.

## Core Domain Concepts

### Tenant Isolation

The RAG Engine Mini is designed as a multi-tenant system where each user's data is completely isolated from others. This is achieved through the `TenantId` value object:

```python
@dataclass(frozen=True)
class TenantId:
    """
    Tenant identifier (typically user_id).
    Frozen to ensure immutability and hashability.
    """
    value: str

    def __str__(self) -> str:
        return self.value
```

Every domain entity and operation is associated with a tenant, ensuring complete data isolation.

### Document Management

The system manages documents through several key entities:

#### DocumentId
A unique identifier for each document:

```python
@dataclass(frozen=True)
class DocumentId:
    """
    Document identifier (UUID string).
    """
    value: str

    def __str__(self) -> str:
        return self.value
```

#### StoredFile
Represents a file that has been stored in the file system:

```python
@dataclass(frozen=True)
class StoredFile:
    """
    Represents a file that has been stored in the file system.
    """
    path: str
    filename: str
    content_type: str
    size_bytes: int
```

#### DocumentStatus
Tracks the lifecycle of a document through the system:

```python
@dataclass
class DocumentStatus:
    """
    Current status of a document in the system.
    Not frozen because status changes over time.
    """
    document_id: DocumentId
    tenant_id: TenantId
    filename: str
    status: str  # "created" | "queued" | "processing" | "indexed" | "failed"
    error: str | None = None
    chunks_count: int = 0
    created_at: datetime | None = None
    updated_at: datetime | None = None
```

The status field tracks the document's journey from upload to being fully indexed and searchable.

## Text Processing Concepts

### Chunking Strategy

The system processes documents by breaking them into smaller chunks for efficient retrieval:

#### ChunkId
Unique identifier for each text chunk:

```python
@dataclass(frozen=True)
class ChunkId:
    """
    Chunk identifier (UUID string).
    """
    value: str

    def __str__(self) -> str:
        return self.value
```

#### Chunk
The fundamental unit of information in the RAG system:

```python
@dataclass(frozen=True)
class Chunk:
    """
    A chunk of text from a document with its metadata.
    """
    id: str
    tenant_id: TenantId
    document_id: DocumentId
    text: str

    # Hierarchical / Contextual retrieval (Stage 2)
    parent_id: str | None = None
    chunk_context: str | None = None  # Document-level context (for Contextual Retrieval)

    def __hash__(self) -> int:
        return hash(self.id)

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Chunk):
            return NotImplemented
        return self.id == other.id
```

Chunks are immutable (frozen) to ensure consistency across the system. The `parent_id` and `chunk_context` fields support hierarchical retrieval strategies.

#### ChunkSpec
Defines how documents should be chunked:

```python
@dataclass(frozen=True)
class ChunkSpec:
    """
    Specification for chunking behavior.
    """
    max_tokens: int = 512
    overlap_tokens: int = 50
    encoding_name: str = "cl100k_base"

    # Hierarchical strategy (Stage 2)
    strategy: str = "fixed"  # fixed, hierarchical, semantic
    parent_size: int = 2048
    child_size: int = 512
```

## RAG-Specific Concepts

### Answer Generation

The system generates answers to user queries:

```python
@dataclass(frozen=True)
class Answer:
    """
    An answer generated by the RAG system.
    """
    text: str
    sources: Sequence[str]  # List of chunk IDs

    def __post_init__(self) -> None:
        # Ensure sources is a tuple for immutability
        if not isinstance(self.sources, tuple):
            object.__setattr__(self, "sources", tuple(self.sources))
```

The `sources` field maintains provenance by tracking which chunks contributed to the answer.

### Upload Process

The upload process is represented by:

```python
@dataclass(frozen=True)
class UploadResult:
    """
    Result of a document upload operation.
    """
    document_id: DocumentId
    status: str  # "queued" | "already_exists" | "failed"
    message: str = ""
```

## Chat System Concepts

The system supports conversational interactions:

### ChatSession
Manages a sequence of related queries:

```python
@dataclass
class ChatSession:
    """
    A chat session containing multiple turns.
    """
    id: str
    tenant_id: TenantId
    title: str | None = None
    created_at: datetime | None = None
```

### ChatTurn
Represents a single question-answer exchange:

```python
@dataclass
class ChatTurn:
    """
    A single question-answer turn in a chat session.
    Includes observability fields for cost/latency tracking.
    """
    id: str
    session_id: str
    tenant_id: TenantId
    question: str
    answer: str
    sources: Sequence[str]
    retrieval_k: int = 0

    # Observability fields
    embed_ms: int | None = None
    search_ms: int | None = None
    llm_ms: int | None = None
    prompt_tokens: int | None = None
    completion_tokens: int | None = None
    created_at: datetime | None = None
```

The observability fields track performance metrics for cost optimization and system monitoring.

## Text Extraction Concepts

### ExtractedText
Represents the result of text extraction from a document:

```python
@dataclass(frozen=True)
class ExtractedText:
    """
    Result of text extraction from a document.
    """
    text: str
    metadata: dict = field(default_factory=dict)
```

## Design Principles

### Immutability
Most domain entities are frozen dataclasses to ensure they remain unchanged once created. This prevents accidental mutations and makes reasoning about the system easier.

### Value Objects
Simple types like `TenantId`, `DocumentId`, and `ChunkId` are wrapped in value objects to provide type safety and prevent confusion between different types of identifiers.

### Explicit Contracts
The domain layer defines clear contracts for what operations are possible, without specifying how they should be implemented. This allows the application and adapter layers to determine the implementation details.

### Business Rules Encapsulation
All business rules related to document management, tenant isolation, and RAG operations are encapsulated in the domain layer, making them easy to understand and maintain.

## Relationship to Clean Architecture

The domain layer in RAG Engine Mini exemplifies Clean Architecture principles:

1. **Independence**: The domain layer has no dependencies on frameworks, databases, or external libraries
2. **Business Focus**: It contains only business entities and rules
3. **Testability**: Domain logic can be tested without external dependencies
4. **Maintainability**: Changes to business rules only affect the domain layer

This design ensures that the core business logic remains stable even as technology choices evolve.
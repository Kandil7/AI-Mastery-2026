# Embedding Storage

Efficient storage and management of vector embeddings is critical for AI/ML applications. This document covers database patterns and strategies for storing, indexing, and retrieving high-dimensional embeddings.

## Overview

Embedding storage involves managing large volumes of high-dimensional vectors (typically 1536-4096 dimensions) generated by ML models. For senior AI/ML engineers, understanding efficient embedding storage patterns is essential for building scalable AI systems.

## Storage Requirements

### Data Characteristics
- **High dimensionality**: 1536-4096+ dimensions per vector
- **Large volume**: Millions to billions of vectors
- **Static nature**: Embeddings rarely change once generated
- **Similarity operations**: Primary access pattern is similarity search
- **Metadata association**: Each embedding has associated metadata

### Performance Requirements
- **Low-latency retrieval**: < 100ms for real-time applications
- **High throughput**: Thousands of queries per second
- **Scalability**: Handle growing datasets without performance degradation
- **Memory efficiency**: Optimize for cost-effective storage

## Storage Architecture Patterns

### Dedicated Vector Databases
- **Pros**: Optimized for ANN search, specialized features
- **Cons**: Vendor lock-in, limited SQL support
- **Examples**: Pinecone, Weaviate, Milvus, Chroma

### Database Extensions
- **Pros**: Leverage existing infrastructure, SQL compatibility
- **Cons**: Limited vector-specific features
- **Examples**: pgvector (PostgreSQL), MongoDB Atlas Vector Search

### Hybrid Approaches
- **Pros**: Best of both worlds, flexible architecture
- **Cons**: Complex implementation, operational overhead
- **Pattern**: Relational DB for metadata + vector DB for embeddings

## Implementation Strategies

### PostgreSQL with pgvector
```sql
-- Schema design for embedding storage
CREATE TABLE embeddings (
    id UUID PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL,  -- 'document', 'user', 'product'
    entity_id VARCHAR(255) NOT NULL,   -- foreign key reference
    embedding vector(1536) NOT NULL,
    metadata JSONB NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexing strategies
-- IVF index (good balance)
CREATE INDEX ON embeddings USING ivfflat (embedding vector_cosine_ops)
WITH (lists = 100);

-- HNSW index (high recall)
CREATE INDEX ON embeddings USING hnsw (embedding vector_cosine_ops)
WITH (m = 16, ef_construction = 100);

-- Partial index for active entities
CREATE INDEX idx_active_embeddings ON embeddings (embedding vector_cosine_ops)
WHERE metadata->>'status' = 'active';

-- Composite index for common query patterns
CREATE INDEX idx_embeddings_entity_type ON embeddings (entity_type, embedding vector_cosine_ops)
INCLUDE (entity_id, metadata);
```

### MongoDB Vector Search
```javascript
// Collection schema
db.embeddings.createIndex(
    { "embedding": "cosine" },
    { 
        name: "vector_index",
        weights: { embedding: 1 }
    }
);

// Insert embeddings with metadata
db.embeddings.insertMany([
    {
        _id: "doc1",
        entityType: "document",
        entityId: "abc123",
        embedding: [0.1, 0.3, 0.5, ...], // 1536 dimensions
        metadata: {
            title: "Introduction to Databases",
            category: "technology",
            publishedDate: new Date("2024-01-15"),
            author: "John Doe"
        },
        createdAt: new Date()
    }
]);

// Vector search with filtering
db.embeddings.aggregate([
    {
        $vectorSearch: {
            index: "vector_index",
            path: "embedding",
            queryVector: [0.1, 0.3, 0.5, ...],
            numCandidates: 100,
            limit: 10,
            filter: {
                $and: [
                    { "metadata.category": { $eq: "technology" } },
                    { "metadata.publishedDate": { $gte: new Date("2024-01-01") } }
                ]
            }
        }
    },
    {
        $project: {
            _id: 1,
            entityType: 1,
            entityId: 1,
            metadata: 1,
            score: { $meta: "vectorSearchScore" }
        }
    }
]);
```

### Custom Hybrid Storage
```sql
-- Metadata in relational database
CREATE TABLE embedding_metadata (
    id UUID PRIMARY KEY,
    entity_type VARCHAR(50) NOT NULL,
    entity_id VARCHAR(255) NOT NULL,
    source_url TEXT,
    title TEXT,
    author TEXT,
    published_date DATE,
    status VARCHAR(20) DEFAULT 'active',
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Embeddings in dedicated vector store (external)
-- Or use separate table with optimized storage
CREATE TABLE embedding_vectors (
    metadata_id UUID PRIMARY KEY REFERENCES embedding_metadata(id),
    embedding vector(1536) NOT NULL,
    -- Partitioned for performance
    partition_key INT NOT NULL
) PARTITION BY LIST (partition_key);

-- Create partitions
CREATE TABLE embedding_vectors_p0 PARTITION OF embedding_vectors
    FOR VALUES IN (0);
CREATE TABLE embedding_vectors_p1 PARTITION OF embedding_vectors
    FOR VALUES IN (1);
-- etc.
```

## Optimization Techniques

### Quantization and Compression
- **PQ (Product Quantization)**: Divide vectors into subvectors and quantize
- **SQ (Scalar Quantization)**: Quantize each dimension independently
- **Binary quantization**: Convert to binary vectors for extreme compression
- **Trade-offs**: Accuracy vs memory vs speed

### Caching Strategies
- **Hot embeddings cache**: Frequently accessed embeddings in memory
- **Query result cache**: Cache common similarity search results
- **Metadata cache**: Frequently accessed metadata in Redis
- **LRU eviction**: Manage memory efficiently

### Index Tuning
- **IVF parameters**: `nlist` (clusters) and `nprobe` (search clusters)
- **HNSW parameters**: `M` (neighbors), `ef_construction`, `ef_search`
- **Automatic tuning**: Use ML to optimize parameters based on query patterns

## AI/ML Specific Patterns

### Multi-Modal Embeddings
- **Text embeddings**: From LLMs, sentence transformers
- **Image embeddings**: From vision models (CLIP, ResNet)
- **Audio embeddings**: From speech models
- **Cross-modal**: Joint embedding spaces

```sql
-- Multi-modal embedding schema
CREATE TABLE multimodal_embeddings (
    id UUID PRIMARY KEY,
    entity_id VARCHAR(255) NOT NULL,
    entity_type VARCHAR(50) NOT NULL,
    modality VARCHAR(20) NOT NULL,  -- 'text', 'image', 'audio'
    embedding vector(768) NOT NULL,  -- Different dimensions per modality
    metadata JSONB NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index by modality and entity type
CREATE INDEX idx_multimodal_entity_modality ON multimodal_embeddings (entity_type, modality, embedding vector_cosine_ops);
```

### Incremental Embedding Updates
- **Batch updates**: Periodic re-embedding of changed content
- **Delta updates**: Only update changed embeddings
- **Versioning**: Track embedding versions for reproducibility
- **Validation**: Ensure embedding quality after updates

### Real-time Embedding Generation
- **Streaming pipelines**: Generate embeddings as data arrives
- **Async processing**: Queue-based embedding generation
- **Rate limiting**: Prevent system overload
- **Error handling**: Retry failed embedding generation

## Scalability Patterns

### Horizontal Scaling
- **Sharding by entity type**: Separate indexes for different content types
- **Time-based sharding**: Recent vs historical embeddings
- **Geographic sharding**: Regional deployment for low latency
- **Tenant sharding**: Multi-tenant isolation

### Vertical Scaling
- **Memory optimization**: Quantization, compression
- **Index optimization**: Tune parameters for available resources
- **Hardware acceleration**: GPU/TPU for embedding generation
- **Connection pooling**: Efficient resource management

## Best Practices

1. **Start with simple indexing**: IVF before HNSW
2. **Monitor recall vs latency**: Balance accuracy and performance
3. **Implement proper monitoring**: Track query performance and errors
4. **Plan for growth**: Choose scalable architecture early
5. **Test with production data**: Synthetic data may not reflect real patterns
6. **Consider hybrid approaches**: Combine vector search with traditional filtering

## Related Resources

- [Vector Databases] - Comprehensive vector database guide
- [Index Optimization] - Advanced indexing techniques
- [RAG Systems] - Embedding storage in RAG contexts
- [AI/ML System Design] - Embedding storage in broader ML architecture